use std::sync::RwLock;

use diesel::{
    r2d2::{ManageConnection, R2D2Connection},
    ConnectionError,
    ConnectionResult,
};
use url::Url;

#[derive(Debug)]
pub struct ConnectionManager<T> {
    inner: RwLock<diesel::r2d2::ConnectionManager<T>>,
    #[cfg(dsql)]
    dsql_url: Option<String>,
}

impl<T> ConnectionManager<T> {
    /// Returns a new connection manager,
    /// which establishes connections to the given database URL.
    pub fn new<S: Into<String>>(database_url: S) -> Self {
        let database_url = database_url.into();

        Self {
            inner: RwLock::new(diesel::r2d2::ConnectionManager::new(&database_url)),
            #[cfg(dsql)]
            dsql_url: if database_url.starts_with("dsql:") {
                Some(database_url)
            } else {
                None
            },
        }
    }
}

impl<T> ManageConnection for ConnectionManager<T>
where
    T: R2D2Connection + Send + 'static,
{
    type Connection = T;
    type Error = diesel::r2d2::Error;

    fn connect(&self) -> Result<T, Self::Error> {
        #[cfg(dsql)]
        if let Some(dsql_url) = &self.dsql_url {
            let url = psql_url(dsql_url).map_err(|e| Self::Error::ConnectionError(e))?;
            self.inner.write().expect("Failed to lock inner connection manager to set DSQL connection URL").update_database_url(&url);
        }

        self.inner.read().expect("Failed to lock inner connection manager to connect").connect()
    }

    fn is_valid(&self, conn: &mut T) -> Result<(), Self::Error> {
        self.inner.read().expect("Failed to lock inner connection manager to check validity").is_valid(conn)
    }

    fn has_broken(&self, conn: &mut T) -> bool {
        self.inner.read().expect("Failed to lock inner connection manager to check if has broken").has_broken(conn)
    }
}

// Cache the AWS SDK config, as recommended by the AWS SDK documentation. The
// initial load is async, so we spawn a thread to load it and then join it to
// get the result in a blocking fashion.
static AWS_SDK_CONFIG: std::sync::LazyLock<ConnectionResult<aws_config::SdkConfig>> = std::sync::LazyLock::new(|| {
    std::thread::spawn(|| {
        let rt = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()?;
        
            std::io::Result::Ok(rt.block_on(aws_config::load_defaults(aws_config::BehaviorVersion::latest())))
    })
        .join()
        .map_err(|e| ConnectionError::BadConnection(format!("Failed to load AWS config for DSQL connection: {e:#?}")))?
        .map_err(|e| ConnectionError::BadConnection(format!("Failed to load AWS config for DSQL connection: {e}")))
});

// Generate a Postgres libpq connection string. The input connection string has
// the following format:
//
// dsql://<dsql-id>.dsql.<aws-region>.on.aws
//
// The generated connection string will have the form:
//
// postgresql://<dsql-id>.dsql.<aws-region>.on.aws/postgres?sslmode=require&user=admin&password=<auth-token>
//
// The auth token is a temporary token generated by the AWS SDK for DSQL. It is
// valid for up to 15 minutes. We cache the last-generated token for each unique
// DSQL connection URL, and reuse it if it is less than 14 minutes old.
pub(crate) fn psql_url(url: &str) -> Result<String, ConnectionError> {
    use std::{
        collections::HashMap,
        sync::{Arc, LazyLock, Mutex},
        time::Duration,
    };

    struct PsqlUrl {
        timestamp: std::time::Instant,
        url: String,
    }

    static PSQL_URLS: LazyLock<Mutex<HashMap<String, Arc<Mutex<Option<PsqlUrl>>>>>> = LazyLock::new(|| Mutex::new(HashMap::new()));

    let mut psql_urls = PSQL_URLS.lock().map_err(|e| ConnectionError::BadConnection(format!("Failed to lock PSQL URLs: {e}")))?;

    let psql_url_lock = if let Some(existing_psql_url_lock) = psql_urls.get(url) {
        existing_psql_url_lock.clone()
    } else {
        let psql_url_lock = Arc::new(Mutex::new(None));
        psql_urls.insert(url.to_string(), psql_url_lock.clone());
        psql_url_lock
    };

    let mut psql_url_lock_guard = psql_url_lock.lock().map_err(|e| ConnectionError::BadConnection(format!("Failed to lock PSQL url: {e}")))?;

    drop(psql_urls);

    if let Some(ref psql_url) = *psql_url_lock_guard {
        if psql_url.timestamp.elapsed() < Duration::from_secs(14 * 60) {
            debug!("Reusing DSQL auth token for connection '{url}'");
            return Ok(psql_url.url.clone());
        }

        info!("Refreshing DSQL auth token for connection '{url}'");
    } else {
        info!("Generating new DSQL auth token for connection '{url}'");
    }
    
    // This would be so much easier if ConnectionError implemented Clone.
    let sdk_config = match *AWS_SDK_CONFIG {
        Ok(ref sdk_config) => sdk_config.clone(),
        Err(ConnectionError::BadConnection(ref e)) => return Err(ConnectionError::BadConnection(e.to_owned())),
        Err(ref e) => unreachable!("Unexpected error loading AWS SDK config: {e}"),
    };

    let mut psql_url = Url::parse(url).map_err(|e| {
        ConnectionError::InvalidConnectionUrl(e.to_string())
    })?;

    let host = psql_url.host_str().ok_or(ConnectionError::InvalidConnectionUrl("Missing hostname in connection URL".to_string()))?.to_string();

    static DSQL_REGION_FROM_HOST_RE: LazyLock<regex::Regex> = LazyLock::new(|| {
        regex::Regex::new(r"^[a-z0-9]+\.dsql\.(?P<region>[a-z0-9-]+)\.on\.aws$").expect("Failed to compile DSQL region regex")
    });
    
    let region = (*DSQL_REGION_FROM_HOST_RE).captures(&host).ok_or(ConnectionError::InvalidConnectionUrl("Failed to find AWS region in DSQL hostname".to_string()))?
        .name("region")
        .ok_or(ConnectionError::InvalidConnectionUrl("Failed to find AWS region in DSQL hostname".to_string()))?
        .as_str()
        .to_string();

    let region = aws_config::Region::new(region);

    let auth_config = aws_sdk_dsql::auth_token::Config::builder()
        .hostname(host)
        .region(region)
        .build()
        .map_err(|e| ConnectionError::BadConnection(format!("Failed to build AWS auth token signer config: {e}")))?;

    let signer = aws_sdk_dsql::auth_token::AuthTokenGenerator::new(auth_config);

    let now = std::time::Instant::now();

    let auth_token = std::thread::spawn(move || {
        let rt = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()?;
        
        rt.block_on(signer.db_connect_admin_auth_token(&sdk_config))
    })
        .join()
        .map_err(|e| ConnectionError::BadConnection(format!("Failed to generate DSQL auth token: {e:#?}")))?
        .map_err(|e| ConnectionError::BadConnection(format!("Failed to generate DSQL auth token: {e}")))?;

    psql_url.set_scheme("postgresql").expect("Failed to set 'postgresql' as scheme for DSQL connection URL");
    psql_url.set_path("postgres");
    psql_url.query_pairs_mut()
        .append_pair("sslmode", "require")
        .append_pair("user", "admin")
        .append_pair("password", auth_token.as_str());

    psql_url_lock_guard.replace(PsqlUrl { timestamp: now, url: psql_url.to_string() });

    Ok(psql_url.to_string())
}